### GIT HUB ###
https://github.com/eazybytes/microservices-with-spring-sectionwise-code/tree/master/section5

 *************************** Docker basics *************************** 

1) What is docker - is a tool that allows application to be packaged with all dependacies and run wherever wanted.
   Software containerazation - can run and deploy containers without using a virtual machine.

2) What is container/image - isolated enviroment that allow us to build and software packages. These packages includs code and all depenacies to run app on any enviroment
   This packages are called also images


3) Docker image vs container. From java perspective 'Docker Image' is like java Class and 'Docker Container' is like object of than Class.
   Using image we can run and deploy any number of insace of than application
  Example:                                  -> (container1 myApp) 
           (image myApp) run three instances -> (container2 myApp) 
                                            -> (container3 myApp) 

4) Image is very usefull. Contains all libraries and dependancies that app needs to run. No need to be installed every time on different enviroment.
   If I have image, my friend can take than image an run on his laptop without installing java and spring. He only need to install docker and with
   command he can convert that image to container and run that appication without problems.

5) Docker HUB - store images in public/private place


*************************** Docker Creating image (Basic approach) *************************** 

1) Inside the main application folder (one level with pom.xml file) create a 'Dockerfile' (without extansion) with content:
    #Start with a base image containing Java runtime
    FROM openjdk:17-jdk-slim as build                                   (need java in our container)

    #Information around who maintains the image
    MAINTAINER eazybytes.com                                             (who is the author)

    # Add the application's jar to the container
    COPY target/accounts-0.0.1-SNAPSHOT.jar accounts-0.0.1-SNAPSHOT.jar  (shows from where to copy the JAR.file)

    #execute the application
    ENTRYPOINT ["java","-jar","/accounts-0.0.1-SNAPSHOT.jar"]            (write command to run the application)
 
 Example in https://github.com/eazybytes/microservices-with-spring-sectionwise-code/tree/master/section5/accounts
  
2) Open a main application folder (one level with pom.xml file) in CMD (Command prompt)
   command to create a new image: docker build . -t dockertest/myapp  | Where '-t' is the image tag name 


3) Create container from image. Open e main application folder (one level with pom.xml file) in CMD (Command prompt)
    execute command: docker run -p 8080:8080 dockertest/myapp | Where "dockertest/myapp" is my image name.
   Can start another with docker run -p 8081:8080 Where 8081 will be ourside word 8080 will be only one instance but can generate more from outside word 8082:8080/8083:8080/8084:8080

4) Commands:
    docker ps (which cointainers are started) / docker stop fc / docker logs -f fc | where 'fc' is the first characters from the container id


*************************** Docker Creating image (using Buildpacks) *************************** 

1) When using Buildpacs Dockerfile in no needed anymore.
2) In pom.xml add:
	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<image>
						<name>eazybytes/${project.artifactId}</name>
					</image>
				</configuration>
			</plugin>
		</plugins>
	</build>

3) Open a main application folder (one level with pom.xml file) in CMD (Command prompt) and run:
   mvn spring-boot:build-image  (use Buildpacs to autamatically generate image)

4) Run the image into container: docker run -p 8090:8090 nameapp/nameapp

5) Push Docker image into a remote Docker hub. Command docker push docker.io/nameapp/nameapp


*************************** Docker-Compose *************************** 

1) Definition: When using Docker extensively, the management of several different containers quickly becomes cumbersome.
    Docker Compose is a tool that helps us overcome this problem and easily handle multiple containers at once. Using YAML Configuration.

2) Check is already instaled: docker-compose --version (By default is installed with docker)

3) Example docker-compose.yml file. Create the file in main application folder (one level with pom.xml file)
----------------------------------------------------
version: "3.8"            -> (docker compose version)

services:

  accounts:
    image: eazybytes/accounts:latest
    mem_limit: 700m
    ports:                -> (porsts when container will start. Can be one ot more)
      - "8080:8080"
    networks:
      - eazybank-network -> (which network to interact with)
    
  loans:
    image: eazybytes/loans:latest
    mem_limit: 700m
    ports:
      - "8090:8090"
    networks:
      - eazybank-network -> (which network to interact with)

 networks:               -> (create a network fol all services)
  eazybank-network:
----------------------------------------------------
4) Command to start docker compose: docker-compose up | Will start all difined microservices inside the file.

5) UPDATE docker compose file to adapt with CONFIG SERVICE 
   (https://github.com/eazybytes/microservices-with-spring-sectionwise-code/tree/master/section7/accounts/docker-compose/default)

 -create different packages for all enviriments and update the compose file depending on the enviroment.
                      default      -> docker-compose.yml
  app/docker-compose/ dev          -> docker-compose.yml
                      production   -> docker-compose.yml
   
----------------------------------------------------
version: "3.8"

services:

  configserver:                                       --> (inluding config server)
    image: eazybytes/configserver:latest
    mem_limit: 700m
    ports:
      - "8071:8071"
    networks:
     - eazybank
      
  accounts:
    image: eazybytes/accounts:latest
    mem_limit: 700m
    ports:
      - "8080:8080"
    networks:
      - eazybank
    depends_on:                    --> (allocate that the 'accounts' depends on 'configserver' Docker compose has to make sure ''configserver' is being started)
      - configserver
    deploy:
      restart_policy:              --> (if accounts fail to start user the provided restart policy)
        condition: on-failure
        delay: 5s
        max_attempts: 3
        window: 120s
    environment:                       --> (choose which envirament to start)
      SPRING_PROFILES_ACTIVE: default
      SPRING_CONFIG_IMPORT: configserver:http://configserver:8071/
----------------------------------------------------
 - Starting All microservices defined in the docker-compose file:
     Command:    docker compose up    (first config server is started becouse other micro services are depend on config server)

----------------------------------------------------
*  Docker commands:

docker compose up          (start)
docker compose up --build  (start with re-build)
docker compose up -d       (start with detach/no log info)

docker exec -it workplaces/be /bin/sh (log into the container and open shell)
      => ls -l => cd/workplaces...
      => tail -f logs/workplaces-backed.log (open logs)

docker compose down

* Docker FE changes
REACT_APP_API=http://127.0.0.1:8080
BACKEND_HOST=212.5.158.125
http://app.workplaces/

Adding hosts in hosts files in windows => C:\Windows\System32\drivers\etc\hosts :  127.0.0.1 app.workplaces
 
----------------------------------------------------

*    Analyse Docker / DockerCompose files

##############################  Dockerfile ############################################################  

FROM maven:3.8.4-openjdk-17 AS build             => взимаме най малкия възможен maven image with jdk
WORKDIR /workplaces-backend

COPY pom.xml .
RUN mvn dependency:go-offline                   => да не тегли абсолютно всички депендансита

COPY src src                                    => копираме соурса
RUN mvn install -DskipTests                     => инсалираме и скипваме тестовете
RUN mkdir -p target/dependency && (cd target/dependency; jar -xf ../*.jar)

#
# Deployment stage                            => (след като се бюлднат всички неща отгоре се идва към Deployment stage)
#
FROM eclipse-temurin:17-jdk-alpine            => alpine = minimize verdsion

WORKDIR /opt                                  => The WORKDIR command is used to define the working directory of a Docker container. Задава се като current (opt/workplaces-backend)

RUN addgroup -S wp-user && adduser -S wp-user -G wp-user     => Adding new user
RUN mkdir -p logs && chown -R wp-user:wp-user logs           => Create logs directory
RUN mkdir -p storage && chown -R wp-user:wp-user storage
USER wp-user

ARG DEPENDENCY=/workplaces-backend/target/dependency
COPY --from=build ${DEPENDENCY}/BOOT-INF/lib workplaces/lib
COPY --from=build ${DEPENDENCY}/META-INF workplaces/META-INF
COPY --from=build ${DEPENDENCY}/BOOT-INF/classes workplaces

ENTRYPOINT ["java", "-cp", "workplaces:workplaces/lib/*", "com.sirma.workplaces.WorkplaceReservationsApplication"] => всичко, което е необходимо да се пусне спринга


##############################  DockerCompose ############################################################  

services:                                => Прави нещо като вътрешен DNS и може да ги достъпваме с съответните имена (backend, db)
    backend:
        image: 'workplaces-be'           => имато на иминджа
        build: .
        container_name: workplaces-be    => имато на контейнера
        init: true
        restart: always                  => ако фелне да пробва да го пусне пак         
        ports:
            - '8080:8080'
        volumes:                         => да не създава нова папка всеки път при деплой или билд /запазва данните
            - be-data:/opt/storage
        depends_on:
            - db
        environment:
            - SPRING_PROFILES_ACTIVE=docker
            - SPRING_DATASOURCE_URL=jdbc:postgresql://db:5432/workplaces_db
            - SPRING_DATASOURCE_USERNAME=workplaces_user
            - SPRING_DATASOURCE_PASSWORD=nqkvamnogotypaparola
            - SPRING_JPA_HIBERNATE_DDL_AUTO=update
        networks:
            - app-network

    db:
        image: 'postgres:14-alpine'
        container_name: workplaces-db
        ports:
            - '5444:5432'
        volumes:
            - db-data:/var/lib/postgresql/data
        environment:
            - POSTGRES_DB=workplaces_db
            - POSTGRES_USER=workplaces_user
            - POSTGRES_PASSWORD=nqkvamnogotypaparola
        networks:
            - app-network                                    ==> network -bridge могад да се виждам помежду си

networks:
    app-network:
        driver: bridge

volumes:
    db-data:
        name: workplaces-db-volume
    be-data:
        name: workplaces-be-volume

******************** Commands and steps in Sirma proejcts **************************
docker compose up
docker compose down
docker compose up --build                 (with re-build)
docker compose up -d                      (run as detach, cannot fallow the log)
docker exec -it workplaces-be /bin/sh     (log into the container// ls -l , cd..)
tail -f /logs/workplaces-be.log           (read logs)

FE:
Define hosts in the window host file
# End of section
127.0.0.1 app.workplaces
127.0.0.1 admin.workplaces

-Access the App: http://app.workplaces

- nginx template:  listen  80; => (от порт 80 да пренасочва към 443)







